#!/usr/bin/env bash

gglib_include tty

GGLIB_DEFAULT_CHECK_WARN_TMO=0

#-------------------------------------------------------------
# %1 W|E
# %2 custom message
# %3 default message (if no custom one)
# %4 timeout for waiting (see wait())
_report_check()
{
local _propmpt="ERROR"
local _msg="$2"
local _tmp=${4:-${GGLIB_DEFAULT_CHECK_WARN_TMO}}}
  [ "$1" = "W" -o "$1" = "w" ] && _propmpt="WARNING"
  [ "$1" = "B" -o "$1" = "b" ] && _propmpt="BUG"
  [ -z "${_msg}" ] && _msg="$3"
  echo "${_propmpt}: ${_msg}"
  [ "${_propmpt:0:1}" != "W" ] && exit 1
  wait_for_abort ${_tmo}
  return 0
}


#-------------------------------------------------------------
 # %1 : level
 # %2 : var
 # %3 : message (optional)
 # %4 : warning wait delay
_check_var()
{
  eval [ -n \"\$$2\" ] && return 0
  _report_check "$1" "$3" "variable $2 expected to have a value" "$4"
}

 # %1 : var
 # %2 : message (optional)
check_var()
{
  _check_var E "$1" "$2"
}

 # %1 : var
 # %2 : message (optional)
check_var_B()
{
  _check_var B "$1" "$2"
}

 # %1 : var
 # %2 : message (optional)
 # %3 : [wait timeout]
check_var_W()
{
  _check_var W "$1" "$2" "$3"
}


#-------------------------------------------------------------
_check_equal_vars()
{
  eval [ "\$$2" = "\$$3" ] && return 0
  _report_check "$1" "$4" "variable $2 != $3" "$5"
}

# %1 : var1
# %2 : var2
# %3 : message (optional)
check_equal_vars()
{
  _check_equal_vars E "$1" "$2" "$3"
}

# %1 : var1
# %2 : var2
# %3 : message (optional)
check_equal_vars_B()
{
  _check_equal_vars B "$1" "$2" "$3"
}

# %1 : var1
# %2 : var2
# %3 : message (optional)
# %4 : [wait timeout]
check_equal_vars_W()
{
  _check_equal_vars W "$1" "$2" "$3" "$4"
}

#-------------------------------------------------------------
# %1 : level
# %2 : variable
# %3 : possible paths roots separated by ":"
# %4 : message
# %5 : [wait timeout]
_check_path_in()
{
local _level="$1"
local _var="$2"
local _paths="$3"
local _msg="$4"
local _delay="$5"
local P PS
  eval P="\$${_var}"
  P="${P%/}"
  
  IFS=":"
  set -- ${_paths}
  IFS=
  
  while [ -n "$1" ]
  do
    [ "${P}" != "${P#$1/}" ] && return 0
  done
  
  _report_check "${_level}" "${_msg}" "variable ${_var}='$P' is not in one of the given paths (${_paths})" "${_delay}"
}

# %1 variable
# %2 possible paths roots separated by :
# %3 optional message
check_path_in()
{
  _check_path_in E "$1" "$2" "$3"
}

# %1 variable
# %2 possible paths roots separated by :
# %3 optional message
check_path_in_B()
{
  _check_path_in B "$1" "$2" "$3"
}

# %1 variable
# %2 possible paths roots separated by :
# %3 optional message
# %4 wait delay time
check_path_in_W()
{
  _check_path_in W "$1" "$2" "$3" "$4"
}

#-------------------------------------------------------------
# %1 : level
# %2 : variable
# %3 : possible words separated by comman (,)
# %4 : optional message
# %5 : [wait timeout]
_check_value_in()
{
local _level="$1"
local _var="$2"
local _vals="$3"
local _msg="$4"
local _delay="$5"
local _v
  eval _v=\"\$${_var}\"

  IFS=,
  set -- ${_vals}
  IFS=
  
  while [ -n "$1" ]
  do
    [ "$_v" = "$1" ] && return 0
    shift
  done
  
  _report_check "${_level}" "${_msg}" "variable ${_var}='${_v}' is not in one of the values ${_vals}" "${_delay}"
}

# %1 variable
# %2 possible paths roots separated by :
# %3 optional message
check_value_in()
{
  _check_value_in E "$1" "$2" "$3"
}

# %1 variable
# %2 possible paths roots separated by :
# %3 optional message
check_value_in_B()
{
  _check_value_in B "$1" "$2" "$3"
}

# %1 variable
# %2 possible paths roots separated by :
# %3 optional message
# %4 wait delay time
check_value_in_W()
{
  _check_value_in W "$1" "$2" "$3" "$4"
}

#-------------------------------------------------------------
# %1 : level
# %2 : variable
# %3 : min elements
# %4 : max elements (<0 -> no max)
# %5 : optional message
# %6 : [wait timeout]
_check_array_size()
{
local _level="$1"
local _var="$2"
local _min="$3" _max="$4"
local _msg="$5"
local _delay="$6"
local _n
  eval _n=\${#${_var}[@]}
  [ $_n -ge $_min ] && [ $_max -lt 0 -o $_n -le $_max ] && return 0
  
  _report_check "${_level}" "${_msg}" "array ${_var} has ${_n} entries, expected ${_min} to ${_max}" "${_delay}"
}

# %1 : variable
# %2 : min elements
# %3 : max elements (<0 -> no max)
# %4 : optional message
check_array_size()
{
  _check_array_size E "$1" "$2" "$3" "$4"
}

check_array_size_B()
{
  _check_array_size B "$1" "$2" "$3" "$4"
}

# %1 : variable
# %2 : min elements
# %3 : max elements (<0 -> no max)
# %4 : optional message
# %5 : [wait timeout]
check_array_size_W()
{
  _check_array_size W "$1" "$2" "$3" "$4" "$5"
}

   
